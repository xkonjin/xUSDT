<!-- fd2c1621-e599-48b9-94e8-b6688c076c5f 51eae0ff-db50-4d8a-a0f9-a87c6c92fb1a -->
# x402‑Like Agent Payments with USD₮ on Plasma (USD₮0) and Ethereum

### Scope and goals

- Build an x402-equivalent for agent-to-agent payments supporting two networks:
- Plasma Layer 1 with USD₮0 (EIP‑2612/EIP‑3009 supported) for near‑zero‑fee, fast settlement
- Ethereum mainnet with USD₮ (USDT) via a gasless Payment Router + EIP‑712 signatures
- Deliver Python agents (merchant, client), a Python facilitator, a Solidity router contract, end‑to‑end tests, and a production deployment guide.

References: [x402 GitHub](https://github.com/coinbase/x402), [x402 specs](https://github.com/coinbase/x402/tree/main/specs), [x402.org](https://x402.org), [Crossmint blog](https://blog.crossmint.com), [arXiv](https://arxiv.org), [Trendshift](https://trendshift.io), [Eco.com A2A guide](https://eco.com), [Plasma docs](https://docs.plasma.to), [Plasma site](https://plasma.to), [OpenZeppelin](https://openzeppelin.com), [Ethereum StackExchange](https://ethereum.stackexchange.com), [Cloudflare blog](https://blog.cloudflare.com), [Curotec](https://curotec.com).

### Architecture summary

- Protocol flow mirrors x402: PaymentRequired → PaymentSubmitted → PaymentCompleted, over HTTP 402 (X‑PAYMENT/X‑PAYMENT‑RESPONSE) or A2A messages.
- Schemes:
- Plasma USD₮0: EIP‑3009 transferWithAuthorization (native token feature); no prior approve; off‑chain EIP‑712 signature; relayed by facilitator.
- Ethereum USDT: Custom PaymentRouter.sol uses EIP‑712 signatures + per‑payer nonce to securely pull tokens via transferFrom; requires one‑time USDT approve to router.
- Multi‑network: Merchant advertises multiple options; client chooses (prefer Plasma for micro‑payments). Nonce + expiry bound to invoice prevents replay.
- Security: EIP‑712 domain separation (chainId, verifyingContract), per‑payer nonces (router) or token‑native nonces (USD₮0), exact‑amount enforcement, 6‑decimal handling.

### Component map and file layout

- contracts/PaymentRouter.sol — EIP‑712 gasless pull for ERC‑20 (USDT on Ethereum)
- hardhat.config.ts, scripts/deploy.ts, test/PaymentRouter.t.ts — Hardhat project for compile/deploy/tests
- x402_usdt_agent/
- core/types.py — Pydantic models: PaymentRequired, PaymentOption, PaymentPayload, Receipt
- core/signing.py — EIP‑712 builders (router struct), EIP‑3009 helpers, 6‑decimal math
- core/networks.py — Chain IDs, RPCs, token/contract addresses, explorer URLs
- http_middleware.py — HTTP 402 handler and header marshalling
- a2a_integration.py — A2A message adaptors (optional if using A2A)
- merchant_agent.py — Price policy, PaymentRequired generator, settlement orchestration
- client_agent.py — Option selection, signature generation, PaymentSubmitted emitter
- facilitator.py — Web3 connectors; settle_eth() via router; settle_plasma() via transferWithAuthorization; confirmation waiters
- config.py — Env loading (.env), key/material validation
- tests/ (pytest): unit tests for signing, parsing, option selection, facilitator stubs
- test_flow.py — End‑to‑end scenario across both networks (small value)
- README.md — Runbooks, explainers per module, network caveats

### Data contracts (essential fields)

- PaymentRequired.accepts[n]:
- scheme: "erc20-auth" | "erc20-router"
- chainId, networkName, tokenAddress, tokenSymbol ("USD₮0" or "USD₮"), decimals=6
- maxAmountRequired (atomic units string), resource, description, mimeType
- recipient: merchantAddress (destination of funds)
- extra: { routerAddress? (ETH), assetName, assetVersion, expirySeconds, invoiceId }
- PaymentSubmitted:
- selectedOption (echoes above), x402Version, payload: { v,r,s, amount, nonce, deadline, from, to, token, router? }
- PaymentCompleted:
- success, txHash, networkId, error?, settledAmount, invoiceId

### Protocol flow (HTTP 402 and/or A2A)

1) Merchant determines charge → returns 402 with PaymentRequired JSON (or payment‑required A2A message).
2) Client selects best option (prefer Plasma), signs:

- Plasma: EIP‑3009 transferWithAuthorization struct
- Ethereum: EIP‑712 Transfer struct for router
Sends PaymentSubmitted including signature payload.
3) Merchant verifies payload off‑chain, calls facilitator:
- Plasma: token.transferWithAuthorization(...)
- Ethereum: router.gaslessTransfer(token, from, to, amount, deadline, v,r,s)
Waits for confirmation, then responds 200 with X‑PAYMENT‑RESPONSE (or payment‑completed A2A message).

### Smart contract design (Ethereum)

- PaymentRouter.sol
- EIP‑712 domain: name=PaymentRouter, version=1, chainId, verifyingContract
- Typehash: Transfer(token, from, to, amount, nonce, deadline)
- Mapping per payer nonces; verify signer == from; consume nonce; require(IERC20(token).transferFrom(from,to,amount))
- No custody; exact‑amount execution; emits event for analytics
- Plasma path
- Prefer native USD₮0 transferWithAuthorization; only deploy router on Plasma as fallback.

### Python facilitator

- settle_eth(payload): connect via web3 to mainnet; call router.gaslessTransfer(...); await N confirmations; return txHash
- settle_plasma(payload): call USD₮0.transferWithAuthorization(...); await confirmation
- Robust error mapping (invalid signature, expired deadline, insufficient allowance/balance)

### Engineering conventions

- Extensive docstrings and inline comments; include a top‑of‑file explainer for every module.
- Centralized constants for chain IDs, token decimals/addresses.
- Amounts handled as Decimal then converted to integer atomic units (6 decimals) to avoid float drift.
- Verification first, settlement next; strict exact‑match amount policy.