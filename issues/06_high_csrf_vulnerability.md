---
title: 'HIGH: Implement CSRF Protection on State-Changing API Endpoints'
labels: security, high, api, bug
---

## 1. Description

The Plenmo application's API endpoints that handle state changes (e.g., sending payments, updating settings) lack Cross-Site Request Forgery (CSRF) protection. An attacker could craft a malicious website that, when visited by a logged-in Plenmo user, would automatically trigger actions on their behalf without their consent.

For example, an attacker could embed a hidden form on their website:
```html
<form action="https://plenmo.com/api/submit-transfer" method="POST">
  <input type="hidden" name="recipient" value="<attacker_address>" />
  <input type="hidden" name="amount" value="1000" />
</form>
<script>document.forms[0].submit();</script>
```
If a logged-in user visits this page, their browser will automatically include their session cookie with the POST request, authorizing the transfer of 1000 units to the attacker's address.

## 2. Impact

- **Unauthorized Fund Transfers:** Attackers can steal funds from users by tricking them into visiting a malicious website.
- **Unauthorized Data Modification:** Attackers could change user settings, such as their registered email or notification preferences.
- **Unauthorized Actions:** Any action available through the API could be performed on the user's behalf, leading to a complete account takeover.

## 3. Modular Outcome (Acceptance Criteria)

- [ ] A CSRF protection mechanism is implemented for all state-changing API routes (POST, PUT, DELETE, PATCH).
- [ ] The **double-submit cookie** pattern is used:
    1.  On login or page load, the server generates a secure, random CSRF token and sets it in a `csrf_token` cookie.
    2.  The frontend JavaScript reads this cookie and includes its value in a custom `X-CSRF-Token` header for every state-changing request.
    3.  The server-side middleware verifies that the `X-CSRF-Token` header value matches the `csrf_token` cookie value.
- [ ] The `auth-middleware.ts` file is updated to include a `withCSRFProtection` wrapper.
- [ ] All relevant API endpoints are wrapped with this new CSRF protection middleware.

## 4. E2E Test Criteria

- **Objective:** Verify that state-changing requests are rejected without a valid CSRF token and succeed with one.

1.  **Request Without CSRF Header:**
    *   Log in to the application to get a valid session.
    *   Use a tool like `curl` or Postman to make a POST request to `/api/submit-transfer` *without* including the `X-CSRF-Token` header.
    *   **Expected Result:** The request is rejected with a `403 Forbidden` error and a message like "Invalid CSRF token".

2.  **Request With Invalid CSRF Header:**
    *   Log in and obtain the `csrf_token` cookie.
    *   Make a POST request to `/api/submit-transfer` with an *incorrect* value in the `X-CSRF-Token` header.
    *   **Expected Result:** The request is rejected with a `403 Forbidden` error.

3.  **Successful Request With Valid CSRF Token:**
    *   Log in and obtain the `csrf_token` cookie.
    *   Make a POST request to `/api/submit-transfer` with the correct `csrf_token` value in the `X-CSRF-Token` header.
    *   **Expected Result:** The request succeeds (assuming all other parameters are valid).

4.  **Non-State-Changing Request:**
    *   Make a GET request to a protected endpoint (e.g., `/api/claims`) without the CSRF header.
    *   **Expected Result:** The request succeeds, as GET requests should not require CSRF protection.

## 5. Specialized Sub-Agent Requirements

- **Agent Name:** `WebApp_Security_Specialist`
- **Skills:**
    - Deep understanding of web security vulnerabilities, including CSRF, XSS, and CORS.
    - Expertise in implementing security patterns in Next.js and React.
    - Proficient with browser security models and HTTP headers.
- **Responsibilities:**
    - Implement the double-submit cookie CSRF protection mechanism.
    - Ensure the implementation is secure and does not introduce new vulnerabilities (e.g., ensuring the token is sufficiently random).
    - Write integration tests to cover the E2E criteria.

## 6. Resources & Best Practices

- **Resource:** [OWASP Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
- **Best Practice:** The CSRF token cookie should be set with the `HttpOnly` flag set to `false` so it can be read by client-side JavaScript, but the session cookie must have `HttpOnly` set to `true`.
- **Best Practice:** Use a cryptographically secure random number generator to create the CSRF token to ensure it is unguessable.
